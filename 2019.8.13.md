# 20190813

###  4835. [파이썬 S/W 문제해결 기본] 1일차 - 구간합

```python
1. 길이가 N인 구간의 시작 인덱스 i의 범위
만약 M = 3이면,
i:0 --> N-3   N-2   N-1  ==> N-M까지 구간을 잡는다.
즉, i:0 --> N-3
j:0 --> M-1까지
maxS = 0(초기값을 정해 놓아야한다.)
minS = 10000*M (or 문제 조건에서 주어준 1000000)
for i:0 --> N-M
    s = 0 (구간의합)(i가 바뀌면 구간이 새로 바뀜.-> 구간이 새로 바뀌면 구간 합이 바뀜)
    for j:0 --> M-1까지
        s = s + A[i+j]
       
    if maxS < s:
        maxS = s
    if maxS > s:
        minS = s
    print(maxS - minS)
```





### 4831. [파이썬 S/W 문제해결 기본] 1일차 - 전기버스

최대로 갔는데 충전기가 없을 수 있다. 갈 수 있는 한 멀리있는 충전기에 간다고 생각해야한다.

```python
# 어떻게 해야할까...
1. 방전 될 때까지 이동(K)
2. 충전기가 없는 경우 가능한 가장 먼 충전기로 이동

[충전기의 위치를 저장하는 방법 결정] # 어떻게 저장하느냐에 따라 풀이 방법이 전혀 달라진다.
1. 정류장 번호를 인덱스로 한 배열에 충전기 위치만 표시(문제에서 주어진 그대로 저장)
만약, 1, 3, 5, 7, 9에 충전기가 있다면
stop[] = {0, 1, 0, 1, ...} or stop[] = {1, 0, 1, 0, ...}

2. 충전기 설치된 정류장 번호로 저장(0번에는 항상 충전할 수 있음)
stop[] = {1, 3, 5, 7, 9} 또는 stop[] = {0, 1, 3, 5, 7, 9}

[방법 1]
stop [] = {0,1,3,5,7,9}
stop[i]에 도착할 수 있는지 확인 - stop[1]-stop[M]
마지막 충전 위치 last (0부터 시작)
stop[i] - stop[last] <= K 인 조건이면 i에 도착가능

우선 이웃한 충전기 사이가 K이내여야 함.
i번째 충전기까지 이동할 수 있는지 확인
stop[i] - stop[last] <= K
stop[1]-stop[0] -> 1 <= 3 가능하면 i 증가
stop[2]-stop[0] -> 3 <= 3
stop[3]-stop[0] -> 5 <= 3, 이동 불가능 last = 2(이전 충전기) 충전횟수 1증가
stop[4]-stop[2] -> 4 <= 3, 이동 불가능 last = 3(i-1) 충전횟수 1증가

처음부터 종점을 포함해 도착 가능 여부를 확인하면
stop[] = {0,1,3,5,7,9,10}
```



























